### CS101 - Week 06
### Software Engineering Principles
### Lesson 02: Naming that tells a story
### Date: Jan 05 2026

Core Principle:
Good naming makes code readable, predictable, and maintainable. Names are a form of communication between developers, including your future self.

1. Noun-Based Variable Names
- Variables that store data or state should be named using nouns.
- Noun names describe what the value represents, not how it is used.
- Clear noun names reduce the need for comments and make code easier to reason about.
- Effective noun naming communicates scope, intent, and meaning at a glance.

2. Verb-Based Names for Actions
- Anything that performs an action should be named using a verb.
- Verb names describe behavior, process, or transformation.
- Action-based naming helps code read like a logical sequence of steps.
- Consistent verb usage improves understanding of control flow and program behavior.

3. Naming as Professional Communication
- Naming is not about cleverness or brevity; it is about clarity and predictability.
- Good names follow common conventions so others can understand the code quickly.
- Poor naming increases cognitive load and slows comprehension.
- Well-named code explains itself without extra documentation.

4. Renaming Code Safely
- Renaming is a safe refactoring technique when behavior does not change.
- Professional renaming focuses on improving clarity while preserving logic.
- All references must remain consistent during renaming.
- Regular, thoughtful renaming improves code quality over time and reduces errors.
    
5. Safe renaming process:
- Decide the story first (e.g., money, game points, travel).
- Rename one concept at a time:
- Change the definition.
- Change every use.
- Run the code to be sure nothing broke.

Short Reflection
This lesson marks a shift from writing code that merely works to writing code that communicates clearly. Naming is introduced not as a cosmetic choice, but as a professional responsibility. Clear, intentional names make programs easier to understand, safer to modify, and more sustainable as projects grow. This mindset sets the foundation for writing code that others—and future versions of myself—can trust and maintain.

